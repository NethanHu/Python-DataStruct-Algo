from typing import List

"""
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的最大利润 。
解题思路：动态规划
1. 因为这是一道动态规划问题，因此我们先找出状态转移方程，除了最大利润之外，我们还有另一个状态（是否在第 i 天持有股票）：
    * 递推公式中，我们对从 i 天到第 i + 1 天进行状态转移，接下来我们分类讨论；
    * 如果在第 i + 1 天持有股票，那么从第 i 天有两个状态可以转移过来。一是我们维持前一天的股票和最大收益（维持 dp[i][1] 状态）；或者是前一天没有股票，选择花钱买入股票（成为 dp[i][0] - p）；
    * 如果在第 i + 1 天没有持有股票，说明有两个状态可以转移过来。一是维持前一天没有股票的状态（维持 dp[i][0] 状态）；或者是前一天有股票，然后在第 i + 1 当天卖了出去（成为 dp[i][1] + p）；
    * 无论是哪两种状态，都是前一天两种状态转移方程中取最大值。
2. 初始状态我们可以进行讨论，这就是为什么我们的 dp 存在着第 -1 个状态：
    * dp[0][0] 当然是 0，因为在第 0 天我们没有初始资金，所以在第 0 天「不持股」的情况下，最大利润是 0；
    * dp[0][1] 是 -10000（极小数），因为假设第一天有股票，那么至少是卖出这个股票之后，收益也必须是「极小的」，因此后续 max 函数就能提取最大值出来。
3. 最后我们求得就是在第 n 天「没有股票」时候的最大收益，因为如果有股票，那么必然是因为前一天买了股票，此时收益肯定会更小。
"""


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n: int = len(prices)
        dp: List[List[int]] = [[0] * 2 for _ in range(n + 1)]
        # dp[0][0] = 0
        dp[0][1] = -10000
        for i, p in enumerate(prices):
            dp[i + 1][0] = max(dp[i][0], dp[i][1] + p)
            dp[i + 1][1] = max(dp[i][1], dp[i][0] - p)
        return dp[n][0]
