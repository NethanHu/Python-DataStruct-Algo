from typing import List

"""
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。
每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
解题思路：回溯+哈希表+数学（用来简化皇后与皇后之间的冲突模型）
1. 我们可以用二维矩阵来存储皇后的位置，但是为了抽象这个问题，我们可以加入一些先验知识：
    * 由于皇后可以按行走，因此下一个皇后必然不可能与其共占同一行；而且每一个皇后都是相同的（也就是全排列），我们只需要让每一个皇后占一行即可，同时也自己占一列；
    * 我们只需要记下来皇后在哪一列，所以我们创建一个 q_loc = [-1, -1, ..., -1]（-1表示位置未定）。假设一个皇后所在行数是r，那么它的具体的位置是在 [r, q_loc[r]]；
    * 所以这本质上是一种哈希编码，可以直接通过r用O(1)时间获取到纵坐标。
2. 我们需要一种算法能够建模两个皇后之间的冲突。因为我们利用先验知识，不会把皇后放在同一行/列中，因此我们如何判断两个皇后斜角是否会冲突呢？
    * 如果是↗️方向，我们知道这两个皇后的横坐标+纵坐标之和相等。因此给定一个皇后的位置[r, q_loc[r]]，接下去的皇后不能放在和等于 r + q_loc[r] 的地方；
      那么一共有几种和的可能性呢？我们斜着数棋盘格子，最小是0（即(0, 0)），最大是2n-2（即(n - 1, n - 1)）。
      我们建立一个哈希表 diag1，如果一个皇后在[r, q_loc[r]]的位置，那么此时哈希表中的 diag1[r + q_loc[r]] = True
    * 如果是↘️方向，我们知道这两个皇后的横坐标-纵坐标之差相等。最小是-(n - 1)（即(0, n - 1)），最大是 n - 1（即(n - 1, 0)）。同理建立哈希表 diag2。
3. 我们构建DFS的逻辑，此时只有一个参数，那就是当前要摆的是第几个皇后：
    * 为了能够在列方向上遍历皇后可以摆的位置，我们设置一个 col 数组，如果当前第n列有皇后了，之后的皇后肯定不能在这一列上摆放；
    * 同理，如果在这一列摆放了皇后，就把当前 col[c] 设置为 True。
4. 递归的逻辑如下：
    * 对于当前dfs中的第n个皇后，我们就把它摆在第r行。如果 col 中还有没有被占据的位置 not occupied，就判断一下放在这里会不会与别的皇后冲突 not (diag1[r + c] or diag2[r - c])；
    * 如果不冲突就摆在这里，占据第col列，同时接下来的棋子也不能和自己冲突 col[c] = diag1[r + c] = diag2[r - c] = True
    * 继续 dfs(n + 1) 递归下一个皇后；
    * 如果当前的皇后已经在最后一行了（事实上是递归到刚好等于n的时候），就打印棋盘并且添加到答案列表中；
    * 回溯的时候就是把这个棋子从棋盘上拿走的时候，首先不再占用当前列和diag，最后把当前棋子设置成未使用状态。
"""


class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        ans: List[List[str]] = []
        q_loc: List[int] = [-1] * n
        col: List[bool] = [False] * n
        diag1: List[bool] = [False] * (n * 2 - 1)
        diag2: List[bool] = [False] * (n * 2 - 1)

        def dfs(r: int) -> None:
            if r == n:
                ans.append(['.' * c + 'Q' + '.' * (n - 1 - c) for c in q_loc])
                return
            for c, occupied in enumerate(col):
                # 如果在c列的皇后还没有下，同时也没有与别的皇后冲突的话
                if not occupied and not (diag1[r + c] or diag2[r - c]):
                    q_loc[r] = c
                    col[c] = diag1[r + c] = diag2[r - c] = True
                    dfs(r + 1)
                    # 回溯步骤
                    col[c] = diag1[r + c] = diag2[r - c] = False
                    q_loc[r] = -1

        dfs(0)
        return ans
