from typing import List

"""
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。
解题思路：抽象二分查找
1. 这道题目能够提升我们对二分查找的抽象思考能力，更好的理解二分查找的本质：
    * 二分查找的本质是通过维护一对双指针，在逐渐相互逼近的循环中，根据不同的不等式条件从而获取「前后」信息，最后更新指针。
2. 这道题目也是如此，我们分析一下我们待比较的 target 是什么，首先排除最小值，因为所有别的元素都比它大，没有有用信息：
    * 我们把最后一个元素当成「有用信息」，即 nums[-1]。每次迭代我们会得到一个数 nums[mid]，我们把它和 nums[-1] 做比较，我们可以得到以下信息：
    * 如果 nums[mid] > nums[-1]：
        - 最后一个元素「一定」是后半段递增数组的最大值，而中间的元素比它大，说明 mid 自己和左边的所有数字都比 nums[-1] 更大，那么数组最小值只能在 mid 右侧；
    * 如果 nums[mid] < nums[-1]：
        - 那说明 mid 正处在后半段递增数组中，mid 所在的位置要么是最小值，要么是要么就在最小值的右边，说明我们往左边继续寻找。
    * nums[mid] 不可能等于 nums[-1]，因为这是题目的要求。
3. 因此，这是一个抽象的二分查找，我们可以在循环中通过不等式信息来获取到继续往哪个方向寻找，从而把复杂度设置在 O(log n) 上。
4. 我们采用开区间写法，我们把 target 变成 nums[-1] 进行判断即可。
    * 事实证明，我们可以把 nums[-1] 当成锚点，想象它提供「有用信息」，但「不参与」搜索自己的一个数字，我们可以不把 r 计算进去 l, r = -1, len(nums) - 1：
    * 相比于 l, r = -1, len(nums)，上一种写法能有效降低内存占用；
    * 最坏的情况就是只旋转一次，最小元素就在 nums[-1]，那么这两种方法内存占用相同，否则上一种写法空间占用更优。
"""


class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 开区间写法，同时我们用不到最后一个数字
        l, r = -1, len(nums) - 1
        while l + 1 < r:
            mid: int = (l + r) // 2
            # 由于元素各不相同，所以以下的判断均为大于或者小于，不可能等于
            if nums[mid] > nums[-1]:
                l = mid
            else:
                r = mid
        return nums[r]
