from typing import List

"""
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
解题思路：动态规划+记忆化搜索
1. 我们面对这类问题的时候，千万不能从中间开始想，否则会进入一种患得患失的状态：“这一家不偷，我也不一定偷上一家啊，还是得看金币多不多...”
2. 动态规划问题从来都不能从中间开始思考，一定是有时间先后顺序的。首先我们从我们看得见的状态出发：
    * 只有一家的时候，不管是不是0，偷了就好，这是我们唯一的赚钱机会；
    * 只有两家的时候，就变成了零和博弈问题，要么偷第一家、要么第二家，哪个更大偷哪个；
    * 超过两家的时候，我们设置一个动态规划数组 dp，这个数组存放的结果是偷到当前这一家的最大收益；同时要记得初始化。
3. 接下来我们找状态转移方程，我们一定要坚信自己的状态转移方程是正确的，而且是从头到尾都适用：
    * 在第 i 家的时候，我们只有两个选择，要么选择偷这一家，并且继承之前的状态 dp[i - 2]，总收入为 nums[i] + dp[i - 2]；
    * 要么选择不偷这一家，选择继承前一家的状态 dp[i - 1]。两者选最大的即可。
"""


class Solution:
    def rob(self, nums: List[int]) -> int:
        n: int = len(nums)
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])
        dp: List[int] = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        # 递推的条件是，要么偷这家然后加上dp[i - 2]；要么就是不偷这家选择 dp[i - 2]
        for i in range(2, n):
            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])
        return dp[-1]
