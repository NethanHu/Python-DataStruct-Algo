from typing import List

"""
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
解题思路：二维动态规划
1. 动态规划的本质是：找出递推关系，从最简单的条件出发，然后一步一步推出下一步的结果；
2. 我们设置一个高 len(text1) + 1、宽 len(text2) + 1 的 DP 数组，选择 +1 的意思是要去除左上角既是 text1[0] 又是 text2[0] 的情况，并且初始化为 0；
    * 首先 dp[i][j] 的含义：代表 text1 的前 i 个字符 (text1[0...i-1]) 与 text2 的前 j 个字符 (text2[0...j-1]) 之间的最长公共子序列的长度；
    * 我们举一个简单的例子来阐述一下行列之间的关系，填表顺序为从左往右逐行填充。假设 text1 = "bec"、text2 = "abc"：
              ""  a   b   c
        ""    0   0   0   0
        b     0   0   1   1
        e     0   0   1   1
        c     0   0   1   2
    * 从第一行看，此时假设 text1 只有 'b' 的时候，单独的 'b' 与 text2 完全体 'abc' 之间的匹配程度：第一个不匹配，所以是0，第二个匹配上了所以是1，
        第三个没有匹配上，我们就继承了左边的最大值，因此 'b' 与 'abc' 之间公共长度为 1；
      从第二行看，此时假设 text1 只有 'be' 的时候，'be' 与 text2 完全体 'abc' 之间的匹配程度，第一个字母 'b' 已经填完了，但是 'e' 不能与任何字母匹配上，
        因此我们的字母 'e' 继承来自上方的最大值（也就是字符串里面的前者 'b' 留下来的匹配长度）；
    * 从列看同理，只不过就是变成了 text1 是完全体，而 text2 是逐字展开。
3. 我们做个总结，递推关系为这样：
    * 如果发现了遍历到的 text1、text2 当前字母相同，既然这相等，那它们一定可以作为公共子序列的一部分。这个新发现的公共字符让我们的LCS长度增加了1。
      此时的LCS长度，就等于 1 加上它们都去掉最后一个字符后的LCS长度，也就是 dp[i + 1][j + 1] = dp[i][j] + 1；
    * 如果此时字母不等，就观察我们上方的例子，它们不可能同时作为LCS的最后一个字符。LCS要么来自于 text1 去掉最后一个字母之后的比较结果，要么来自于 text2 去掉最后一个字母之后的比较结果。
      而我们要求最长的公共长度，我们保留最长的信息，也就是 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
4. 最后的结果当然就是递推结束的元素，最右下角的 dp[-1][-1]。
"""


class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        n, m = len(text1), len(text2)
        dp: List[List[int]] = [[0] * (m + 1) for _ in range(n + 1)]
        for i, t1 in enumerate(text1):
            for j, t2 in enumerate(text2):
                dp[i + 1][j + 1] = dp[i][j] + 1 if t1 == t2 else max(dp[i][j + 1], dp[i + 1][j])
        return dp[-1][-1]


if __name__ == '__main__':
    s = Solution()
    print(s.longestCommonSubsequence('bec', 'abc'))
